<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

  <title>Thunder - Matching request path to routes</title>
  <link rel="stylesheet" href="/stylesheets/default.css" type="text/css" media="screen" charset="utf-8" />
  <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" media="screen" charset="utf-8" />
  <link rel="shortcut icon" type="image/png" href="favicon.png" />
  <link rel="alternate" type="application/rss+xml" title="thunder-ex.org" href="http://thunder-ex.org/feed.xml">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47281287-1', 'thunder-ex.github.io');
  ga('send', 'pageview');
  </script>

</head>


<body>
  <div class = "site">
    <div span="title"><a href="/"><img src="/images/logo-icon.png" height="17"> Thunder</a> - Elixir Web Framework</div>

    <div id = 'post'><h1>Matching request path to routes</h1>

<p><small>On Sunday, January 19, 2014 by Darko Fabijan</small></p>

<p>In this post we will create some very basic and probably incomplete path parsing along with route matcher. Relevant pull request is <a href="https://github.com/thunder-ex/thunder/pull/1/files">#1</a>.</p>

<p>Once HTTP request reaches handler we need to do couple of things:</p>

<ol>
<li>Parse requested path</li>
<li>Match it with one of defined routes (which also have to be parsed)</li>
<li>Call controller action</li>
<li>Collect output generated by controller action and pass it to cowboy to return it to requester</li>
</ol>


<p></p>


<h2>Path parsing</h2>

<p>First step is to parse path and to do that we first have to split path. It's implemented in <code>Thunder.Router.PathUtils</code> module and is pretty much one-liner. <a href="https://github.com/thunder-ex/thunder/blob/3a1b751ef8d89c26bacfaba265eb4bb54091ac33/test/thunder/router/path_utils_test.exs">Tests</a> are in <code>Thunder.Router.PathUtilsTest</code>.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">lc</span> <span class="n">segment</span> <span class="n">inlist</span> <span class="nc">String</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">),</span> <span class="n">segment</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="n">segment</span>
<span class="k">end</span></code></pre></div>


<p>Only operation that we have to do after that is to turn resulting list into HashDict. It will be nice structure to work with during matching. It's defined in <code>Thunder.Router.Path</code> <a href="https://github.com/thunder-ex/thunder/blob/3a1b751ef8d89c26bacfaba265eb4bb54091ac33/lib/thunder/router/path.ex">module</a>.</p>

<p>And so we are done with basic path parsing which sums up to splitting path with <code>/</code>. Structure that we get for path <code>"/albums/45/photos/1"</code> is <code>[segment: "albums", segment: "45", segment: "photos", segment: "1"]</code>.</p>

<h2>Route parsing</h2>

<p>Parsing defined routes is almost the same as path passing with addition that we will have to recognize <code>:id</code> pattern as binding so we can later extract it. Below is the module responsible for this part.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Thunder.Router.PathPattern</span> <span class="k">do</span>

  <span class="kd">def</span> <span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">lc</span> <span class="n">element</span> <span class="n">inlist</span> <span class="nc">Thunder.Router.PathUtils</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">case</span> <span class="n">element</span> <span class="k">do</span>
        <span class="p">&lt;&lt;</span><span class="mi">58</span><span class="p">,</span> <span class="n">binding</span> <span class="p">::</span> <span class="n">binary</span><span class="p">&gt;&gt;</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="ss">:binding</span><span class="p">,</span> <span class="n">binding</span><span class="p">}</span>
        <span class="bp">_</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="ss">:segment</span><span class="p">,</span> <span class="n">element</span><span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></div>


<p>Route defined as <code>/albums/:album_id/photos/:id/edit</code> will be turned into <code>[segment: "albums", binding: "album_id", segment: "photos", binding: "id", segment: "edit"]</code>.</p>

<h2>Route matching</h2>

<p>This part is in prototype stage since it doesn't take into account HTTP method. As we have seen above we have HashDict for requested path and list of HashDicts for defined routes.</p>

<p>It's easiest to explain this with extract from the <a href="https://github.com/thunder-ex/thunder/blob/8d217e693f5f30f6febbbcfe62dd4bcc96ebef7f/test/thunder/router_test.exs">test</a>:</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Thunder.RouterTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span>

  <span class="kn">require</span> <span class="nc">Thunder.Router</span><span class="p">,</span> <span class="ss">as</span><span class="p">:</span> <span class="nc">R</span>
  <span class="kn">require</span> <span class="nc">Thunder.Router.Path</span><span class="p">,</span> <span class="ss">as</span><span class="p">:</span> <span class="nc">Path</span>
  <span class="kn">require</span> <span class="nc">Thunder.Router.PathPattern</span><span class="p">,</span> <span class="ss">as</span><span class="p">:</span> <span class="nc">PathPattern</span>

  <span class="n">test</span> <span class="s2">&quot;match /albums &lt;=&gt; /albums/:id/edit&quot;</span> <span class="k">do</span>
    <span class="n">path</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;/albums&quot;</span><span class="p">)</span>
    <span class="n">path_pattern</span> <span class="p">=</span> <span class="nc">PathPattern</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;/albums/:id/edit&quot;</span><span class="p">)</span>

    <span class="n">assert</span> <span class="nc">R</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_pattern</span><span class="p">)</span> <span class="o">==</span> <span class="no">false</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;match /albums/12/photos/1 &lt;=&gt; /albums/:album_id/photos/:id&quot;</span> <span class="k">do</span>
    <span class="n">path</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;/albums/12/photos/1&quot;</span><span class="p">)</span>
    <span class="n">path_pattern</span> <span class="p">=</span> <span class="nc">PathPattern</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;/albums/:album_id/photos/:id&quot;</span><span class="p">)</span>

    <span class="n">assert</span> <span class="nc">R</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_pattern</span><span class="p">)</span> <span class="o">==</span> <span class="no">true</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></div>


<p>The actual matcher is at the moment defined in <code>Thunder.Router</code>. It is likely that it will moved to some Matcher module in future. This part of code is really interesting because it relies heavily on pattern matching. It don't know how this implementation would look like in Ruby but this definitely feels mathematically elegant.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Thunder.Router</span> <span class="k">do</span>

  <span class="kd">def</span> <span class="n">match_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">parsed_path</span> <span class="p">=</span> <span class="nc">Thunder.Router.Path</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">routes</span> <span class="p">=</span> <span class="nc">Thunder.Router.Routes</span><span class="p">.</span><span class="n">routes</span>

    <span class="nc">Enum</span><span class="p">.</span><span class="n">find</span> <span class="n">routes</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">match</span><span class="p">(</span><span class="n">parsed_path</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match</span><span class="p">([],</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="no">true</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match</span><span class="p">([</span><span class="n">path_head</span> <span class="p">|</span> <span class="n">path_tail</span><span class="p">],</span> <span class="p">[</span><span class="n">path_pattern_head</span> <span class="p">|</span> <span class="n">path_pattern_tail</span><span class="p">])</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">match_segment</span><span class="p">(</span><span class="n">path_head</span><span class="p">,</span> <span class="n">path_pattern_head</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">match</span><span class="p">(</span><span class="n">path_tail</span><span class="p">,</span> <span class="n">path_pattern_tail</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">false</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match</span><span class="p">([</span><span class="n">path_head</span> <span class="p">|</span> <span class="n">path_tail</span><span class="p">],</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="no">false</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match</span><span class="p">([],</span> <span class="p">[</span><span class="n">path_pattern_head</span> <span class="p">|</span> <span class="n">path_pattern_tail</span><span class="p">])</span> <span class="k">do</span>
    <span class="no">false</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match_segment</span><span class="p">({</span><span class="ss">:segment</span><span class="p">,</span> <span class="n">path_segment</span><span class="p">},</span> <span class="p">{</span><span class="ss">:segment</span><span class="p">,</span> <span class="n">path_pattern_segment</span><span class="p">})</span> <span class="k">do</span>
    <span class="n">path_segment</span> <span class="o">==</span> <span class="n">path_pattern_segment</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">match_segment</span><span class="p">({</span><span class="ss">:segment</span><span class="p">,</span> <span class="bp">_</span><span class="p">},</span> <span class="p">{</span><span class="ss">:binding</span><span class="p">,</span> <span class="bp">_</span><span class="p">})</span> <span class="k">do</span>
    <span class="no">true</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></div>


<p>Implementation is as I said incomplete but I learned from practicing TDD that it's just fine. Once bigger pieces of the puzzle fall into place it's easy to go back, demonstrate missing feature with falling test and add missing part. To test it from browser I had to fall-back to good old <code>puts</code> driven development and added lines below to <code>RequestHandler</code>.</p>

<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">match</span> <span class="p">=</span> <span class="nc">Thunder.Router</span><span class="p">.</span><span class="n">match_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="nc">IO</span><span class="p">.</span><span class="n">puts</span> <span class="n">inspect</span><span class="p">(</span><span class="n">match</span><span class="p">)</span></code></pre></div>


<p>Next stop would be to define some basic DSL for specifying routes.</p>
</div>

    <div id="disqus_thread"></div>
<script type="text/javascript">
     /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
     var disqus_shortname = 'thunder-ex'; // required: replace example with your forum shortname

     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
 </script>
 <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



    <div class='footer'>
  <div class="contact">
    <p>
      Thunder is released under the MIT license.<br/>
      <small>Site is built using <a href="http://jekyllrb.com" class="silent">Jekyll</a> and theme created by <a href="http://michaelrbernste.in/" class="silent">Michael Robert Bernstein</a>. It's <a href="https://github.com/thunder-ex/thunder-ex.github.io" class="silent">open-source</a>.</small>
    </p>
  </div>
</div>


  </div>
</body>

</html>
