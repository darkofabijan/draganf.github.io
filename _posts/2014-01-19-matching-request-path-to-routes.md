---
layout: post
title: "Matching request path to routes"
published: true
ctm: true
---
# Matching request path to routes

<small>On Sunday, January 19, 2014 by Darko Fabijan</small>

In this post we will create some very basic and probably incomplete path parsing along with route matcher. Relevant pull request is [#1](https://github.com/thunder-ex/thunder/pull/1/files).

Once HTTP request reaches handler we need to do couple of things:

1. Parse requested path
2. Match it with one of defined routes (which also have to be parsed)
3. Call controller action
4. Collect output generated by controller action and pass it to cowboy to return it to requester
<p></p>

## Path parsing

First step is to parse path and to do that we first have to split path. It's implemented in `Thunder.Router.PathUtils` module and is pretty much one-liner. [Tests](https://github.com/thunder-ex/thunder/blob/3a1b751ef8d89c26bacfaba265eb4bb54091ac33/test/thunder/router/path_utils_test.exs) are in `Thunder.Router.PathUtilsTest`.

{% highlight elixir %}
def parse(path) do
  lc segment inlist String.split(path, "/"), segment != "", do: segment
end
{% endhighlight %}

Only operation that we have to do after that is to turn resulting list into HashDict. It will be nice structure to work with during matching. It's defined in `Thunder.Router.Path` [module](https://github.com/thunder-ex/thunder/blob/3a1b751ef8d89c26bacfaba265eb4bb54091ac33/lib/thunder/router/path.ex).

And so we are done with basic path parsing which sums up to splitting path with `/`. Structure that we get for path `"/albums/45/photos/1"` is `[segment: "albums", segment: "45", segment: "photos", segment: "1"]`.

## Route parsing

Parsing defined routes is almost the same as path passing with addition that we will have to recognize `:id` pattern as binding so we can later extract it. Below is the module responsible for this part.

{% highlight elixir %}
defmodule Thunder.Router.PathPattern do

  def parse(path) do
    lc element inlist Thunder.Router.PathUtils.parse(path) do
      case element do
        <<58, binding :: binary>> -> {:binding, binding}
        _ -> {:segment, element}
      end
    end
  end

end
{% endhighlight %}

Route defined as `/albums/:album_id/photos/:id/edit` will be turned into `[segment: "albums", binding: "album_id", segment: "photos", binding: "id", segment: "edit"]`.

## Route matching

This part is in prototype stage since it doesn't take into account HTTP method. As we have seen above we have HashDict for requested path and list of HashDicts for defined routes.

It's easiest to explain this with extract from the [test](https://github.com/thunder-ex/thunder/blob/8d217e693f5f30f6febbbcfe62dd4bcc96ebef7f/test/thunder/router_test.exs):

{% highlight elixir %}
defmodule Thunder.RouterTest do
  use ExUnit.Case

  require Thunder.Router, as: R
  require Thunder.Router.Path, as: Path
  require Thunder.Router.PathPattern, as: PathPattern

  test "match /albums <=> /albums/:id/edit" do
    path = Path.parse("/albums")
    path_pattern = PathPattern.parse("/albums/:id/edit")

    assert R.match(path, path_pattern) == false
  end

  test "match /albums/12/photos/1 <=> /albums/:album_id/photos/:id" do
    path = Path.parse("/albums/12/photos/1")
    path_pattern = PathPattern.parse("/albums/:album_id/photos/:id")

    assert R.match(path, path_pattern) == true
  end

end
{% endhighlight %}

The actual matcher is at the moment defined in `Thunder.Router`. It is likely that it will moved to some Matcher module in future. This part of code is really interesting because it relies heavily on pattern matching. It don't know how this implementation would look like in Ruby but this definitely feels mathematically elegant.

{% highlight elixir %}
defmodule Thunder.Router do

  def match_path(path) do
    parsed_path = Thunder.Router.Path.parse(path)
    routes = Thunder.Router.Routes.routes

    Enum.find routes, fn(route) -> match(parsed_path, route) end
  end

  def match([], []) do
    true
  end

  def match([path_head | path_tail], [path_pattern_head | path_pattern_tail]) do
    if match_segment(path_head, path_pattern_head) do
      match(path_tail, path_pattern_tail)
    else
      false
    end
  end

  def match([path_head | path_tail], []) do
    false
  end

  def match([], [path_pattern_head | path_pattern_tail]) do
    false
  end

  def match_segment({:segment, path_segment}, {:segment, path_pattern_segment}) do
    path_segment == path_pattern_segment
  end

  def match_segment({:segment, _}, {:binding, _}) do
    true
  end

end
{% endhighlight %}

Implementation is as I said incomplete but I learned from practicing TDD that it's just fine. Once bigger pieces of the puzzle fall into place it's easy to go back, demonstrate missing feature with falling test and add missing part. To test it from browser I had to fall-back to good old `puts` driven development and added lines below to `RequestHandler`.

{% highlight elixir %}
match = Thunder.Router.match_path(path)
IO.puts inspect(match)
{% endhighlight %}

Next stop would be to define some basic DSL for specifying routes.
